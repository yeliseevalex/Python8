# Важливо! Порожня множина створюється тільки через set(), оскільки {} - це порожній словник
empty_set = set()  # Створюємо порожню множину

# Створення множин з елементів
numbers = {2, 3, 1, 4, 1, 1, 5}  # Повторювані елементи автоматично видаляються
print(numbers)  # Виводимо множину (повторів не буде)

fruits = {"banana", "apple", "cherry"}  # Множина з фруктів
print(fruits)  # Виводимо множину

# Створення множини з елементів списку
list1 = [1, 2, 2, 3, 4, 5, 1, 2, 3, 4, 7, 8, 100, 10]
unique_numbers = set(list1)  # Створення множини з унікальних елементів списку
list1 = sorted(list(unique_numbers))  # Сортуємо множину і перетворюємо назад на список
print(unique_numbers)  # Виводимо множину з унікальними елементами
print(list1)  # Виводимо відсортований список з унікальними елементами

# Операції з множинами
s = {1, 2, 3}
s.add(4)  # Додає елемент до множини
print(s)  # Виводимо множину після додавання елементу

s = {1, 2, 3, 50, 75}
s.add(100)  # Додає новий елемент
print(s)  # Виводимо множину

# Хешування рядка
text = 'Python Programming'
hash_value = hash(text)  # Обчислюємо хеш-значення змінної text
print(hash_value)  # Виводимо хеш-значення

# Операції з множинами
s = {1, 2, 3}
s.add(10)  # Додаємо елемент
print(s)  # Виводимо множину
s.remove(2)  # Видаляємо елемент (викликає помилку, якщо елементу немає в множині)
s.discard(8)  # Видаляє елемент без помилки, якщо його немає
s.pop()  # Видаляє випадковий елемент
print(s)  # Виводимо множину після видалення
s.clear()  # Очищає множину
print(s)  # Виводимо порожню множину

# Об'єднання множин
A = {1, 2, 3}
B = {3, 4, 5}
C = A.union(B)  # Об'єднання множин A та B
D = B.union(A)  # Об'єднання множин B та A
E = A | B  # Той самий результат через оператор |
print(C)  # Виводимо результат об'єднання
print(D)  # Виводимо результат об'єднання
# print(E)  # Якщо потрібно вивести ще один варіант, раскоментуйте

# Перетин множин
A = {1, 2, 3}
B = {2, 3, 4, 5}
C = A.intersection(B)  # Перетин множин A та B
D = B.intersection(A)  # Перетин множин B та A
E = A & B  # Той самий результат через оператор &
print(C)  # Виводимо перетин
print(D)  # Виводимо перетин
print(E)  # Виводимо перетин

# Оновлення множини
B.intersection_update(A)  # Оновлює B, залишаючи тільки елементи, які є в A
print(f"A = {A}")  # Виводимо множину A
print(f"B = {B}")  # Виводимо множину B

# Різниця множин
A = {1, 2, 3}
B = {3, 4, 5}
C = A.difference(B)  # Різниця множин A та B
D = B.difference(A)  # Різниця множин B та A
E = A - B  # Той самий результат через оператор -
F = B - A  # Той самий результат через оператор -
print(C)  # Виводимо різницю
print(D)  # Виводимо різницю
print(E)  # Виводимо різницю
print(F)  # Виводимо різницю
A.difference_update(B)  # Оновлює A, видаляючи елементи, які є в B
print(f"A = {A}")  # Виводимо оновлену множину A
print(f"B = {B}")  # Виводимо множину B

# Симетрична різниця множин
A = {1, 2, 3}
B = {3, 4, 5}
C = A.symmetric_difference(B)  # Симетрична різниця множин A та B
D = B.symmetric_difference(A)  # Симетрична різниця множин B та A
E = A ^ B  # Той самий результат через оператор ^
F = B ^ A  # Той самий результат через оператор ^
print(C)  # Виводимо симетричну різницю
print(D)  # Виводимо симетричну різницю
print(E)  # Виводимо симетричну різницю
print(F)  # Виводимо симетричну різницю

# Перевірка відношень між множинами
A = {1, 5, 6, 7}
B = {1, 2, 3, 4}
print(A.issubset(B))  # Перевіряємо, чи є A підмножиною B
print(B.issuperset(A))  # Перевіряємо, чи є B надмножиною A
print(A.issuperset(B))  # Перевіряємо, чи є A надмножиною B
print(A.isdisjoint(B))  # Перевіряємо, чи не перетинаються множини A та B

# Приклад заморожених множин
set1 = set([1, 2, 3, 4])  # Звичайна множина
print(set1)  # Виводимо множину
fset = frozenset({1, 2, 3, 4})  # Заморожена множина
print(fset)  # Виводимо заморожену множину
